---
title: "[BOJ-3273] Lass uns das Problem der zwei Summen auf zwei Arten l√∂sen (Hash, Two Pointer) Mit Go"
type: blog
date: 2025-05-21
comments: true
translated: true
---

## Problem

[**BOJ-3273 Direktlink**](https://www.acmicpc.net/problem/3273)

```
n verschiedene positive Ganzzahlen a1, a2, ..., an. Die Werte ai sind nat√ºrliche Zahlen, die >= 1 und <= 1000000 sind.

Schreibe ein Programm, das die Anzahl der Paare (ai, aj) berechnet, die die Bedingung ai + aj = x (1 ‚â§ i < j ‚â§ n) erf√ºllen.
```

Es ist gefragt, ob die Summe aus dem gegebenen Array die vorgegebene Zahl x ergibt.
> Zur Vereinfachung werde ich im Folgenden `x` als `target` bezeichnen.

## 1. Mit doppelter Schleife l√∂sen

Als ich das Problem das erste Mal sah, dachte ich, dass ich einfach das Array zweimal durchlaufen k√∂nnte, um das Ergebnis zu finden.

Die Kernlogik sieht folgenderma√üen aus:

```go
package main

import "fmt"

func main() {
	// ... Initialisierungscode

	count := 0
	for i, num := range arr {
		for j, num2 := range arr {
			if i >= j {
				continue
			}
			if num+num2 == target {
				count++
			}
		}
	}
	fmt.Println(count)
}
```

Dies ist eine naive Methode, die das Array zweimal durchl√§uft.

Da die Einschr√§nkung f√ºr n jedoch `1 ‚â§ n ‚â§ 100000` betr√§gt, w√ºrde diese Methode im schlechtesten Fall `O(n^2)` kosten.

Wenn die maximale Eingabe kommt, m√ºssten `100.000 * 100.000 = 10.000.000.000` Vergleiche angestellt werden.

Ziemlich erwartungsgem√§√ü f√ºhrt das tats√§chliche Ausf√ºhren dieses Codes zu einem Timeout.

![image](/images/algorithm/boj-3273-1747819709525.png)

Wir m√ºssen also eine schnellere und effizientere L√∂sung finden.

## 2. Mit Two Pointers l√∂sen

Es gibt eine Methode namens Two Pointers. Dabei bewegen sich zwei Zeiger √ºber ein Array, um die L√∂sung zu finden.

In diesem Fall k√∂nnen wir das Problem mit dem Two Pointer Ansatz einfach l√∂sen, wenn wir das Array sortieren.

Die beiden Pointer `start` und `end` beginnen mit `start` von 0 und `end` von n-1.

Nehmen wir beispielsweise folgende Eingabe:

```go
arr = [5, 1, 3, 2, 4]
target = 5
```

Nach dem Sortieren sieht das Array folgenderma√üen aus:

| index | 0 | 1 | 2 | 3 | 4 |
|-------|:-:|:-:|:-:|:-:|:-:|
| value | 1 | 2 | 3 | 4 | 5 |

Jetzt schauen wir mit `start` auf `0` und `end` auf `4`.

### Stage 1

`count = 0`

| index |     0     | 1 | 2 | 3 |    4    |
|:-----:|:---------:|:-:|:-:|:-:|:-------:|
| value |     1     | 2 | 3 | 4 |    5    |
|       | **start** |   |   |   | **end** |

Die Summe der beiden Zahlen betr√§gt 6.

Da diese gr√∂√üer als 5 ist, senken wir `end`.

### Stage 2

`count = 0`

| index |     0     | 1 | 2 |    3    | 4 |
|:-----:|:---------:|:-:|:-:|:-------:|:-:|
| value |     1     | 2 | 3 |    4    | 5 |
|       | **start** |   |   | **end** |   |

Nun betr√§gt die Summe der beiden Zahlen 5.

Da die Summe mit `target` √ºbereinstimmt, erh√∂hen wir `count`.

Da das Array unterschiedliche Werte hat, bewegen wir beide Pointer.
`start` wird auf 1 und `end` auf 2 gesetzt.

### Stage 3

`count = 1`

| index | 0 |     1     |    2    | 3 | 4 |
|:-----:|:-:|:---------:|:-------:|:-:|:-:|
| value | 1 |     2     |    3    | 4 | 5 |
|       |   | **start** | **end** |   |   |

Wenn wir die Pointer verschieben, betr√§gt die Summe wieder 5.

Da diese mit dem `target` √ºbereinstimmt, erh√∂hen wir erneut `count`.

Beim Verschieben der Pointer wird `start` auf 2 und `end` auf 1 gesetzt.

Da nun `start` gr√∂√üer als `end` ist, beenden wir den Vorgang.

### Zeitkomplexit√§t

Die Zeitkomplexit√§t dieser Logik betr√§gt O(n) dank der Two Pointers, aber durch das Sortieren ben√∂tigt man O(n*Log(n)), sodass die finale Zeitkomplexit√§t O(n*Log(n)) betr√§gt.

### Finale Code
Der finale Code sieht folgenderma√üen aus:

```go 
package main

import (
	"bufio"
	"fmt"
	"log"
	"os"
	"sort"
)

// https://www.acmicpc.net/problem/3273 - Zwei Summen

func main() {
	writer := bufio.NewWriter(os.Stdout)
	reader := bufio.NewReader(os.Stdin)
	defer writer.Flush()

	var n int
	if _, err := fmt.Fscanln(reader, &n); err != nil {
		log.Fatal(err)
	}

	arr := make([]int, n)
	for i := 0; i < n; i++ {
		if _, err := fmt.Fscan(reader, &arr[i]); err != nil {
			log.Fatal(err)
		}
	}
	if _, err := fmt.Fscanln(reader); err != nil {
		log.Fatal(err)
	}
	var target int
	if _, err := fmt.Fscanln(reader, &target); err != nil {
		log.Fatal(err)
	}

	sort.Ints(arr)

	count := 0
	start, end := 0, len(arr)-1
	for start < end {
		sum := arr[start] + arr[end]
		if sum == target {
			count++
			start++
			end--
		}
		if sum > target {
			end--
		}
		if sum < target {
			start++
		}
	}

	fmt.Println(count)
}
```

## 3. Mit Hash l√∂sen

Man kann auch eine Hash-Methode verwenden, um das Problem zu l√∂sen.

Hierbei wird ein Komplement und eine Hashmap verwendet.

Wenn wir zum Beispiel das Komplement von 4 zu 10 betrachten, ergibt das `10 - 4 = 6`.

Werfen wir einen Blick auf die Logik mit demselben Array:

Bei Verwendung von Hash ist kein Sortieren erforderlich, und die Schleife muss nur einmal durchlaufen werden.

| index | 0 | 1 | 2 | 3 | 4 |
|-------|:-:|:-:|:-:|:-:|:-:|
| value | 1 | 2 | 3 | 4 | 5 |

### Stage 1

`count = 0`

**Array**

| index |    0    | 1 | 2 | 3 | 4 |
|-------|:-------:|:-:|:-:|:-:|:-:|
| value |    5    | 1 | 3 | 2 | 4 |
|       | **`i`** |   |   |   |   |

**Hashmap**

| Aktueller Wert | |
|:----:|:-:|
| idx  | |

Zuerst ist der Wert an `i` 5. Wir pr√ºfen, ob der Wert des Komplements 0 in der Hashmap vorhanden ist.

Wenn nicht, bleibt der Count gleich, und wir f√ºgen den aktuellen Wert in die Hashmap ein.

### Stage 2

`count = 0`

**Array**

| index | 0 |    1    | 2 | 3 | 4 |
|-------|:-:|:-------:|:-:|:-:|:-:|
| value | 5 |    1    | 3 | 2 | 4 |
|       |   | **`i`** |   |   |   |

**Hashmap**

| Aktueller Wert | 5 |
|:----:|:-:|
| idx  | 0 |

Jetzt, bei `i=1`, ist der Wert 1, und wir suchen das Komplement 4 in der Hashmap.

Da der Schl√ºssel 4 nicht vorhanden ist, bleibt der Count gleich, und wir f√ºgen den aktuellen Wert in die Hashmap ein.

### Stage 3

`count = 0`

**Array**

| index | 0 | 1 |    2    | 3 | 4 |
|-------|:-:|:-:|:-------:|:-:|:-:|
| value | 5 | 1 |    3    | 2 | 4 |
|       |   |   | **`i`** |   |   |

**Hashmap**

| Aktueller Wert | 5 | 1 |
|:----:|:-:|:-:|
| idx  | 0 | 1 |

Jetzt ist der Wert bei `i=2`, der 3 ergibt, und wir suchen das Komplement 2 in der Hashmap.

Da der Schl√ºssel 2 nicht vorhanden ist, bleibt der Count gleich und wir f√ºgen den aktuellen Wert in die Hashmap ein.

### Stage 4

`count = 0`
**Array**

| index | 0 | 1 | 2 | 3 | 4 |
|-------|:-:|:-:|:-:|:-------:|:-:|:-:|
| value | 5 | 1 | 3 | 2 | 4 |
| | | | | **`i`** | |

**Hashmap**

| Aktueller Wert | 5 | 1 | 3 |
|:----:|:-:|:-:|:-:|
| idx  | 0 | 1 | 2 |

Jetzt ist der Wert bei `i=3`, der 2 ergibt. Wir suchen nach dem Komplement 3 in der Hashmap.

Da der Schl√ºssel 3 vorhanden ist, erh√∂hen wir den Count und f√ºgen dann den aktuellen Wert in die Hashmap ein.

### Stage 5

`count = 1`

**Array**
| index | 0 | 1 | 2 | 3 | 4 |
|-------|:-:|:-:|:-:|:-:|:-------:|
| value | 5 | 1 | 3 | 2 | 4 |
| | | | | | **`i`** |

**Hashmap**
| Aktueller Wert | 5 | 1 | 3 | 2 |
|:---:|:-:|:-:|:-:| :-:|
| idx | 0 | 1 | 2 | 3 |

Jetzt ist der Wert bei `i=4`, der 4 ergibt. Wir suchen nach dem Komplement 1 in der Hashmap.

Der Schl√ºssel 1 ist vorhanden, also erh√∂hen wir den Count und f√ºgen dann den aktuellen Wert hinzu.

### Ergebnis

`count = 2`
**Array**
| index | 0 | 1 | 2 | 3 | 4 |
|-------|:-:|:-:|:-:|:-:|:-:|
| value | 5 | 1 | 3 | 2 | 4 |

**Hashmap**
| Aktueller Wert | 5 | 1 | 3 | 2 | 4 |
|:---:|:-:|:-:|:-:|:-:| :-:|
| idx | 0 | 1 | 2 | 3 | 4 |

`i` hat nun den Wert 5 erreicht, und wir beenden den Vorgang. 

Der finale Count betr√§gt 2.

### Zeitkomplexit√§t

Die Verwendung einer Hashmap erfordert keine Sortierung, und die Schleife wird nur einmal ausgef√ºhrt, was zu O(n) Zeitkomplexit√§t f√ºhrt.

Die Hashmap hat jedoch m√∂glicherweise, abh√§ngig von den Eingaben, einen hohen Speicherbedarf. (Nat√ºrlich variiert die speichertechnische Komplexit√§t je nach Implementierung der Hashmap.)  

### Finale Code
Hier ist die Implementierung in Go:

```go
package main

import (
	"bufio"
	"fmt"
	"log"
	"os"
)

// https://www.acmicpc.net/problem/3273 - Zwei Summen

func main() {
	writer := bufio.NewWriter(os.Stdout)
	reader := bufio.NewReader(os.Stdin)
	defer writer.Flush()

	var n int
	if _, err := fmt.Fscanln(reader, &n); err != nil {
		log.Fatal(err)
	}

	arr := make([]int, n)
	for i := 0; i < n; i++ {
		if _, err := fmt.Fscan(reader, &arr[i]); err != nil {
			log.Fatal(err)
		}
	}
	if _, err := fmt.Fscanln(reader); err != nil {
		log.Fatal(err)
	}
	var target int
	if _, err := fmt.Fscanln(reader, &target); err != nil {
		log.Fatal(err)
	}

	count := 0
	idxMap := make(map[int]int)
	for i, num := range arr {
		// Suche nach der Komplementzahl
		if _, ok := idxMap[target-num]; ok {
			count++
		}
		// F√ºge aktuellen Wert zur Hashmap hinzu
		idxMap[num] = i
	}

	if _, err := fmt.Fprintln(writer, count); err != nil {
		log.Fatal(err)
	}
}
```

## Fazit

Wir konnten das Problem mit Hash und Two Pointers l√∂sen.

Ich habe dieses Problem erneut durchgearbeitet und zusammengefasst, weil √§hnlichen Typen von Problemen bei Coding Tests auftreten k√∂nnen.

Ich habe dummerweise mit Methode 1 begonnen.ü§£ 

~~(Vielleicht, weil ich lange kein Algorithmusproblem mehr gel√∂st habe, habe ich einfach zu einfach gedacht.)~~

Anschlie√üend habe ich versucht, es mit Binary Search zu l√∂sen, was nicht funktionierte, aber nach ein wenig √úberlegung fand ich eine gute L√∂sung.

~~(Warum denke ich w√§hrend einer Pr√ºfung nie an solche L√∂sungen? „Ö†„Ö†)~~

Es w√§re gut, √§hnliche Probleme regelm√§√üig zu √ºben und sie zu dokumentieren, um bei Pr√ºfungen hilfreich zu sein.

Hugh, weiter geht's!