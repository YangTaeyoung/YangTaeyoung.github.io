---
title: "[BOJ-3273] R√©solvons le probl√®me de la somme de deux nombres de deux mani√®res (Hash, Two Pointers) avec Go"
type: blog
date: 2025-05-21
comments: true
translated: true
---

## Probl√®me

[**Acc√©der √† BOJ-3273**](https://www.acmicpc.net/problem/3273)

```
n nombres entiers positifs distincts a1, a2, ..., an composent une s√©quence. La valeur de ai est un entier naturel qui est sup√©rieur ou √©gal √† 1 et inf√©rieur ou √©gal √† 1000000.  

Quand on nous donne un nombre naturel x, √©crivons un programme pour compter le nombre de paires (ai, aj) telles que ai + aj = x (1 ‚â§ i < j ‚â§ n).
```

Le probl√®me consiste √† d√©terminer si une somme correspond au nombre d√©sign√© x dans le tableau donn√© comme ci-dessus.  
> Pour des raisons de commodit√©, nous appellerons `x` `target` ci-apr√®s.

## 1. R√©soudre avec une double boucle

Lorsqu'on a d'abord re√ßu le probl√®me, on pourrait penser qu'on peut le r√©soudre en parcourant le tableau deux fois pour trouver.

L'algorithme cl√© est le suivant.

```go
package main

import "fmt"

func main() {
	// ... code d'initialisation

	count := 0
	for i, num := range arr {
		for j, num2 := range arr {
			if i >= j {
				continue
			}
			if num+num2 == target {
				count++
			}
		}
	}
	fmt.Println(count)
}
```

La m√©thode consiste simplement √† effectuer une double boucle pour trouver sans finesse.

Cependant, avec la contrainte de n, `1 ‚â§ n ‚â§ 100000`,si nous utilisons cette m√©thode, dans le pire des cas, cela donnera un `O(n^2)`.

Si nous avons une entr√©e maximale de `100,000 * 100,000 = 10,000,000,000`, le nombre de comparaisons n√©cessaires est gigantesque.

Naturellement, si nous ex√©cutons r√©ellement ce code, nous obtiendrons un d√©passement de temps.

![image](/images/algorithm/boj-3273-1747819709525.png)

Nous devons r√©fl√©chir √† une r√©ponse plus rapide et plus efficace.

## 2. R√©soudre avec les deux pointeurs

Il existe une m√©thode appel√©e "deux pointeurs" o√π deux pointeurs se d√©placent sur un seul tableau pour trouver la solution.

Dans ce cas particulier, si le tableau est tri√©, le probl√®me peut √™tre facilement r√©solu avec les deux pointeurs.

En prenant un tableau tri√© comme r√©f√©rence, `start` commence √† 0 et `end` commence √† n-1.

Supposons qu'il y ait une entr√©e comme celle-ci:

```go
arr = [5, 1, 3, 2, 4]
target = 5
```

Une fois tri√©, cela ressemblera √† ceci.

| index | 0 | 1 | 2 | 3 | 4 |
|-------|:-:|:-:|:-:|:-:|:-:|
| value | 1 | 2 | 3 | 4 | 5 |

Maintenant, commen√ßons √† chercher √† `start = 0` et `end = 4`.

### √âtape 1

`count = 0`

| index |     0     | 1 | 2 | 3 |    4    |
|:-----:|:---------:|:-:|:-:|:-:|:-------:|
| value |     1     | 2 | 3 | 4 |    5    |
|       | **start** |   |   |   | **end** |

La somme des deux nombres est 6.

C'est sup√©rieur √† 5, donc nous diminuons `end`.

### √âtape 2

`count = 0`

| index |     0     | 1 | 2 |    3    | 4 |
|:-----:|:---------:|:-:|:-:|:-------:|:-:|
| value |     1     | 2 | 3 |    4    | 5 |
|       | **start** |   |   | **end** |   |

Maintenant, la somme des deux est 5.

La somme correspond √† `target`, donc nous augmentons `count`.

Comme le tableau comporte des valeurs distinctes, nous d√©pla√ßons les deux pointeurs. `start` passe √† 1, `end` √† 2.

### √âtape 3

`count = 1`

| index | 0 |     1     |    2    | 3 | 4 |
|:-----:|:-:|:---------:|:-------:|:-:|:-:|
| value | 1 |     2     |    3    | 4 | 5 |
|       |   | **start** | **end** |   |   |

M√™me en d√©pla√ßant les pointeurs, la somme est toujours 5.

Ceci correspond √† `target`, donc nous augmentons `count`.

En d√©pla√ßant, `start` devient 2, `end` devient 1.

Maintenant, `start` est sup√©rieur √† `end`, donc nous arr√™tons.

### Complexit√© temporelle

La complexit√© temporelle de cette m√©thode avec deux pointeurs est O(n), mais le tri n√©cessite `O(n*Log(n))`, donc la complexit√© finale est `O(n*Log(n))`.

### Code final
Le code final est le suivant.

```go 
package main

import (
	"bufio"
	"fmt"
	"log"
	"os"
	"sort"
)

// https://www.acmicpc.net/problem/3273 - Somme de deux nombres

func main() {
	writer := bufio.NewWriter(os.Stdout)
	reader := bufio.NewReader(os.Stdin)
	defer writer.Flush()

	var n int
	if _, err := fmt.Fscanln(reader, &n); err != nil {
		log.Fatal(err)
	}

	arr := make([]int, n)
	for i := 0; i < n; i++ {
		if _, err := fmt.Fscan(reader, &arr[i]); err != nil {
			log.Fatal(err)
		}
	}
	if _, err := fmt.Fscanln(reader); err != nil {
		log.Fatal(err)
	}
	var target int
	if _, err := fmt.Fscanln(reader, &target); err != nil {
		log.Fatal(err)
	}

	sort.Ints(arr)

	count := 0
	start, end := 0, len(arr)-1
	for start < end {
		sum := arr[start] + arr[end]
		if sum == target {
			count++
			start++
			end--
		}
		if sum > target {
			end--
		}
		if sum < target {
			start++
		}
	}

	fmt.Println(count)
}
```

## 3. Impl√©mentation avec un Hash

Le probl√®me peut √©galement √™tre r√©solu en utilisant un hash.

Nous utiliserons le compl√©ment et le hashmap.

Par exemple, le compl√©ment de 4 pour 10 est `10 - 4 = 6`.

Voyons la logique avec le m√™me tableau qu'auparavant:

Nous n'avons pas besoin de trier avec un hash, et nous ne devons parcourir la boucle qu'une seule fois.

| index | 0 | 1 | 2 | 3 | 4 |
|-------|:-:|:-:|:-:|:-:|:-:|
| value | 1 | 2 | 3 | 4 | 5 |

### √âtape 1

`count = 0`

**Tableau**

| index |    0    | 1 | 2 | 3 | 4 |
|-------|:-------:|:-:|:-:|:-:|:-:|
| value |    5    | 1 | 3 | 2 | 4 |
|       | **`i`** |   |   |   |   |

**Hashmap**

| Valeur actuelle | |
|:----:|:-:|
| idx  | |

D'abord, avec `i` ayant une valeur de 5. V√©rifiez si le compl√©ment, qui est 0, est dans le hashmap.

Ce n'est pas le cas, donc le compteur reste inchang√© et nous ajoutons la valeur actuelle au hashmap.

### √âtape 2

`count = 0`

**Tableau**

| index | 0 |    1    | 2 | 3 | 4 |
|-------|:-:|:-------:|:-:|:-:|:-:|
| value | 5 |    1    | 3 | 2 | 4 |
|       |   | **`i`** |   |   |   |

**Hashmap**

| Valeur actuelle | 5 |
|:----:|:-:|
| idx  | 0 |

Ensuite, pour `i=1`, la valeur est 1, donc nous cherchons le compl√©ment, qui est 4, dans le hashmap.

Comme il n'existe pas de cl√© 4 dans le hashmap, le compteur reste inchang√© et nous ajoutons la valeur actuelle au hashmap.

### √âtape 3

`count = 0`

**Tableau**

| index | 0 | 1 |    2    | 3 | 4 |
|-------|:-:|:-:|:-------:|:-:|:-:|
| value | 5 | 1 |    3    | 2 | 4 |
|       |   |   | **`i`** |   |   |

**Hashmap**

| Valeur actuelle | 5 | 1 |
|:----:|:-:|:-:|
| idx  | 0 | 1 |

Puis, pour `i=2`, la valeur est 3, et le compl√©ment, qui est 2, n'est pas dans le hashmap. Nous ajoutons simplement la valeur actuelle.

### √âtape 4

`count = 0`

**Tableau**

| index | 0 | 1 | 2 | 3 | 4 |
|-------|:-:|:-:|:-:|:-------:|:-:|:-:|
| value | 5 | 1 | 3 | 2 | 4 |
| | | | | **`i`** | |

**Hashmap**

| Valeur actuelle | 5 | 1 | 3 |
|:----:|:-:|:-:|:-:|
| idx  | 0 | 1 | 2 |

Pour `i=3`, la valeur est 2, donc cherchons le compl√©ment, qui est 3, dans le hashmap.  
Il existe une cl√© 3, donc nous augmentons le compteur et ajoutons la valeur actuelle au hashmap.

### √âtape 5

`count = 1`

**Tableau**

| index | 0 | 1 | 2 | 3 | 4 |
|-------|:-:|:-:|:-:|:-:|:-------:|
| value | 5 | 1 | 3 | 2 | 4 |
| | | | | | **`i`** |

**Hashmap**

| Valeur actuelle | 5 | 1 | 3 | 2 |
|:---:|:-:|:-:|:-:| :-:|
| idx | 0 | 1 | 2 | 3 |

Pour `i=4`, la valeur est 4. Donc, cherchons son compl√©ment, qui est 1, dans le hashmap. 
√âtant donn√© que la cl√© 1 existe, nous augmentons le compteur de 1 et ajoutons la valeur actuelle.

### R√©sultat

`count = 2`
**Tableau**
| index | 0 | 1 | 2 | 3 | 4 |
|-------|:-:|:-:|:-:|:-:|:-:|
| value | 5 | 1 | 3 | 2 | 4 |

**Hashmap**
| Valeur actuelle | 5 | 1 | 3 | 2 | 4 |
|:---:|:-:|:-:|:-:|:-:| :-:|
| idx | 0 | 1 | 2 | 3 | 4 |

Comme `i` atteint 5, l'algorithme s'arr√™te, et le nombre final de paires est de 2.

### Complexit√© temporelle
L'utilisation du hash ne n√©cessite pas de tri, et on n'ex√©cute la boucle qu'une seule fois. Cela donne une complexit√© temporelle de `O(n)`.  
Il faut cependant noter que la consommation de m√©moire pourrait augmenter consid√©rablement en fonction de l'entr√©e.

### Code final
Le code correspondant en Go est le suivant.

```go
package main

import (
	"bufio"
	"fmt"
	"log"
	"os"
)

// https://www.acmicpc.net/problem/3273 - Somme de deux nombres

func main() {
	writer := bufio.NewWriter(os.Stdout)
	reader := bufio.NewReader(os.Stdin)
	defer writer.Flush()

	var n int
	if _, err := fmt.Fscanln(reader, &n); err != nil {
		log.Fatal(err)
	}

	arr := make([]int, n)
	for i := 0; i < n; i++ {
		if _, err := fmt.Fscan(reader, &arr[i]); err != nil {
			log.Fatal(err)
		}
	}
	if _, err := fmt.Fscanln(reader); err != nil {
		log.Fatal(err)
	}
	var target int
	if _, err := fmt.Fscanln(reader, &target); err != nil {
		log.Fatal(err)
	}

	count := 0
	idxMap := make(map[int]int)
	for i, num := range arr {
		// Cherchez le compl√©ment pour num
		if _, ok := idxMap[target-num]; ok {
			count++
		}
		// Ajoutez la valeur actuelle au hashmap
		idxMap[num] = i
	}

	if _, err := fmt.Fprintln(writer, count); err != nil {
		log.Fatal(err)
	}
}
```

## Conclusion

Nous avons r√©ussi √† r√©soudre le probl√®me en utilisant des techniques de Hash et de deux pointeurs.

J'ai revu et r√©sum√© cela pour me pr√©parer √† aborder des probl√®mes similaires lors des tests de codage.

Je me consid√®re un peu idiot d'avoir utilis√© la premi√®re m√©thode.ü§£  

~~(Apr√®s avoir r√©solu un probl√®me d'algorithme depuis longtemps, j'ai perdu mon sens, donc j'ai pens√© trop simplement.)~~

J'ai √©galement essay√© de le r√©soudre en utilisant la recherche binaire, mais en fin de compte, en r√©fl√©chissant davantage, j'ai pu trouver une bonne m√©thode.

~~(Pourquoi n'arrive-t-on pas √† penser √† de telles m√©thodes lors des examens ? „Ö†„Ö†)~~

Il semble que je devrais souvent r√©soudre ce type de probl√®me et prendre le temps de le r√©sumer afin que cela m'aide √©galement lors des examens.

Allez, courage !